### 词法分析

编译器的第一个步骤，词法分析 lexical analysis 或者 扫描 scanning

词法单元 token

position = initial + rate * 60

(1) position 是一个词素，被映射成词法单元 <id, 1>

    id 表示标识符 identifier 的抽象符号
	
	1 指向符号表中position 对应的条目
	
    符号表条目存放该标识符的一些信息，例如：名字和类型
	
(2) 赋值符号 = 是一个词素，被映射成词法单元 <=>
    因为这个词法单元不需要属性值，所以可以省略第二个分量
	
(3) initial 是一个词素，词法单元 <id, 2>
    其中2 表示 initial对应的符号表条目
	
(4) + 是一个词素，词法单元是 <+>

(5) rate 是一个词素，词法单元是 <id, 3>

(6) * 是一个词素，词法单元是 <*>

(7) 60 是一个词素，词法单元是 <60>

即 position = initial + rate * 60

  <id, 1> <=> <id, 2> <+> <id, 3> <*> <60>

### 语言分类

第一代语言，机器语言
第二代语言，汇编语言
第三代语言，Fortran\Cobol\Lisp\C\C++\Java 等高级语言
第四代语言，特定应用设计的语言，例如：生成报告的NOMAD, 数据库查询SQL，文本排版Postscript
第五代语言，基于逻辑和约束的语言，例如Prolog/OPS5


强制式语言 imperative , 程序中指明如何完成一个计算任务的语言
例如: C/C++/C#/Java
声明式语言 declarative, 程序中指明要进行哪些计算的语言
例如: ML/Haskell/Prolog


冯诺依曼语言 von Neumann language 


### 面向对象的主要思想

1. 数据抽象

2. 特性的继承


RISC reduced instruction set computer 精简指令集计算机

CISC complex instruction set computer 复杂指令集计算机

### 程序审计语言基础

静态: 如果一个语言使用的策略支持编译器静态决定某个问题，则这个语言使用了一个静态的策略，
	或者说这个问题可以在编译时刻决定 compile time

动态: 如果只允许在运行程序的时候做出决定策略，称之为动态策略
	或者说需要在运行时刻做出决定 run time
	
作用域： x 的一个声明的作用域 scope 是指程序的一个区域，在其中对 x 的使用都指向这个声明
	
静态作用域：如果仅仅通过阅读程序就可以确定一个声明的作用域，则这个语言使用了静态作用域
	      static scope，或者说是词法作用域 lexical scope，例如: C/Java

动态作用域：当程序运行时候，同一个对x的使用会指向x 的几个声明中的某一个



### 标识符、变量

标识符： identifier, 是一个字符串，通常由字母和数字组成，用于指向（标记）一个实体，
	比如一个数据对象、过程、类或者类型，
	所有的标识符都是名字，但并不是所有的名字都是标识符，例如：
	x, y都是名字，也都是标识符，但是 x.y 是一个名字，却表示x指定的结构体的y字段，
	即x.y 是一个表达式，不是一个标识符
	
变量：是指向存储中的某个特定位置，同一个标识符被多次声明是一个很常见的事情
     每一个声明将引入一个新的变量，即使每个标识符只是声明了一次，一个递归过程中的局部标识符将在不同时刻指向不同的存储位置
	 
	 
### public, private , protected

通过关键字 public, private, protected, 面向对象语言提供了对超类中的成员名字的显式访问控制

这些关键字，通过限制访问来支持封装 encapsulation

private 仅仅包含了该类和友类相关的方法声明和定义

protected 名字可以由子类访问

public可以从类外访问


### 动态作用域

对一个名字x的使用指向的是最近被调用但是还没有终止，且声明了x的过程的这个声明

动态作用域解析对于多态过程是必不可少的

多态过程，对一个同一个名字根据参数类型具有两个或者多个定义的过程

### 静态/动态作用域的对比

从某种意义上，动态规则处理时间的方式类似于静态作用域处理空间的方式

静态规则，让我们寻找的声明位于最内层的、包含了变量使用时间的单元（过程调用）中。

### 参数传递机制

值调用，

call-by-value, 会对实参求值（如果是表达式）或者拷贝（如果是变量）
这些拷贝会被放在属于被调用过程的行参的内存位置上
值调用的效果是，被调用过程所做的所有有关形参的计算都局限于这个过程，但是相应的实参本身不会被改变

但是，作为参数传递的是一个指针或者数组名称，则虽然会拷贝一个地址的变量，但是仍然可以修改数组中的元素

引用调用

call-by-reference, 实参地址作为相应的行参的值被传递给被调用者
在被调用者的代码中使用形参时候，实现方法是：沿着这个指针找到调用者指明的内存位置，

因此，改变形参看起来就像是改变了实参一样

引用调用在某些场景几乎是无法避免的，例如：当形参是一个大型的对象、数组或者结构时候，如果使用
严格的值调用，会要求调用者把整个实参拷贝到属于相应的形参的空间上，当参数很大时候，拷贝代价很大。

### 名调用

不再使用




